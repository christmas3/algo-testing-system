# Таблица времени выполнения 100000 операций. Значения в секундах. 

| Массив         | put middle | put front | put back | get random | get front | get back | remove front | remove middle | remove back |
| :---           |   ---:     |   ---:    |   ---:   |   ---:     |   ---:    |   ---:   |   ---:       |   ---:        |   ---:      |
| SingleArray    | 0.977209   | 0.956756  | 0.941513 | 0.005573   | 0.000839  | 0.000838 | 0.951425     | 0.933998      | 0.913839    |
| VectorArray    | 0.404642   | 0.795753  | 0.100162 | 0.005840   | 0.000878  | 0.000853 | 0.788888     | 0.326251      | 0.001887    |
| FactorArray    | 0.299765   | 0.664228  | 0.001693 | 0.005749   | 0.000854  | 0.000860 | 0.662818     | 0.298430      | 0.001887    |
| MatrixArray    | 1.698276   | 3.484657  | 0.004336 | 0.007462   | 0.002382  | 0.002434 | 2.728410     | 1.344418      | 0.004521    |
| StlVectorArray | 0.303369   | 0.648166  | 0.002518 | 0.006072   | 0.001174  | 0.001136 | 0.664765     | 0.315290      | 0.003850    |

# SingleArray
Динамический массив, в котором при добавлении/удалении элемента выделяется новая область памяти, на единицу больше/меньше
текущей. Далее копируется в выделенную память элементы из старой памяти и добавляется/удаляется элемент. Старая память освобождается.
По времени видим, что операции удаления/добавления в любые позиции занимают приблизительно одинаково большие значения.
Сложность добавления/удаления элемента из массива O(N^2).
Сложность чтения элемента из любой позиции O(1).
Время чтения из случайной позиции больше из-за генерации случайного числа.
Эффективен по объему занимаемой памяти.

# VectorArray
В данном динамическом массиве память выделяется не по 1 элементу, а порциями (в данном примере по 10 элементов).
Соответственно, если память есть свободная, то добавление элемента в конец не требует выделения памяти и копирования элементов.
По времени добавление в конец работает быстрее примерно в 10 раз.
Добавление в начало или середину так же требует выделения памяти только каждый 10 раз, но необходимо сдвигать последующие элементы на 1 позицию вправо.
Удаление из конца массива имеет сложность O(1). Удаление из других позиций имеет сложность O(N), так как необходимо сдвигать последующие
элементы на 1 позицию влево.

# FactorArray
Объем новой выделяемой памяти в 2 раза больше старой. Соответственно количество выделений памяти и копирований будет примерно равно logN, 
где N - количество операций добавления. Выделение больших порций памяти может привести к неэффективному ее использованию.

# MatrixArray
Реализация представляет собой набор массивов фиксированной длины (в данном случае 100 элементов). При отсутствии памяти выделяется новый 
массив фиксированного размера, куда копируется новый элемент. Перемещение старых элементов не требуется.
Элементы массива хранятся в памяти не последовательно. Операция доступа к элементу требует дополнительных вычислений. 
Операция добавления и удаления в произвольную позицию требует выравнивания элементов в массивах и дополнительная сложность реализации

# StlVectorArray
Обертка над std::vector. По времени выполнения операций приблизительно совпадает с FactorArray, из чего можно сделать вывод о схожем 
принципе работы.
